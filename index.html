<!DOCTYPE html>
<html>
<head>
	<title>Udacity Todos Goals</title>
</head>
<body>
	<div>
		<h1>Todo List</h1>
		<input id='todo' type='text' placeholder='Add Todo' />
		<button id='todoBtn'>Add Todo</button>
		<ul id='todos'></ul>
	</div>
	<div>
		<h1>Goals</h1>
		<input id='goal' type='text' placeholder='Add Goal' />
		<button id='goalBtn'>Add Goal</button>
		<ul id='goals'></ul>
	</div>


	<script type="text/javascript">
		function generateId () {
			return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36)
		}

					// ---* Library Code *---//

		function createStore(reducer) {
			//The store should have four parts
			//1. the state
			//2. Get the state
			//3. Listen to state changes
			//4. Update the state

			let state
			let listeners = []

			const getState = () => state

			const subscribe = (listener) => {
				listeners.push(listener)
				return () => {
					listeners = listeners.filter((l) => l !== listener)
				}
			}

			//Store dispatch function to update state inside the store (part 4)
			const dispatch = (action) => {
				state = reducer(state, action)
				listeners.forEach((listener) =>listener())
			}

			return {
				getState,
				subscribe,
				dispatch
			}

		}

		// ---* App Code *---//


		//Pefer constants than strings as the values of type properties. 
		//Both work  -- but when using constants, the console with throw an error rather than fail silently
		//should be any misspellings
		const ADD_TODO = 'ADD_TODO'
		const REMOVE_TODO = 'REMOVE_TODO'
		const TOGGLE_TODO = 'TOGGLE_TODO'
		const ADD_GOAL = 'ADD_GOAL'
		const REMOVE_GOAL = 'REMOVE_GOAL'

		//-Action Creators-//
		function addTodoAction (todo) {
			return {
				type: ADD_TODO,
				todo,
			}
		}

		function removeTodoAction (id) {
			return {
				type: REMOVE_TODO,
				id,
			}
		}

		function toggleTodoAction (id) {
			return {
				type: TOGGLE_TODO,
				id,
			}
		}

		function addGoalAction (goal) {
			return {
				type: ADD_GOAL,
				goal,
			}
		}

		function removeGoalAction (id) {
			return {
				type: REMOVE_GOAL,
				id,
			}
		}

		//The Reducer function is responsible to updating the state based on the current action
		//It takes alwas to arguments, the "state" and the "action"
		//This has to be a pure function to increase predictability.
		//So the function doesn't modify the current, instead with the concat() method it creates a new one,
		// in order to remain pure.
		function todos(state = [], action) {
			switch (action.type){
				case ADD_TODO :
					return state.concat([action.todo])
				case REMOVE_TODO :
					return state.filter((todo) => todo.id !== action.id)
				case TOGGLE_TODO :
					return state.map((todo) => todo.id !== action.id ? todo :
						Object.assign({}, todo, { complete: !todo.complete }))
				default: 
					return state
			}
		}

		function goals (state = [], action) {
			switch(action.type) {
				case ADD_GOAL :
					return state.concat([action.goal])
				case REMOVE_GOAL :
					return state.filter((goal) => goal.id !== action.id)
				default :
					return state
			}
		}

		//-Root Reducer-//
		function app(state = {}, action){
			return {
				//The reducer functions just managing the specific slice of the the state now
				todos: todos(state.todos, action),
				goals: goals(state.goals, action),
			}
		}

		//createStore() must be passed a "reducer" function, when it's invoked.
		const store = createStore(app)

		store.subscribe(() => {
			const { goals, todos } = store.getState()

			document.getElementById('goals').innerHTML = ''
			document.getElementById('todos').innerHTML = ''

			goals.forEach(addGoaltoDOM)
			todos.forEach(addTodotoDOM)
		})


		// ---* DOM Code *---//
		function AddTodo () {
			const input = document.getElementById('todo')
			const name = input.value
			input.value = ''

			store.dispatch(addTodoAction({
				name,
				complete: false,
				id: generateId()
			}))
		}

		function AddGoal () {
			const input = document.getElementById('goal')
			const name = input.value
			input.value = ''

			store.dispatch(addGoalAction({
				name,
				id: generateId()
			}))
			
		}

		document.getElementById('todoBtn')
			.addEventListener('click', AddTodo)

		document.getElementById('goalBtn')
			.addEventListener('click', AddGoal)


		function createRemoveButton(onClick) {
			const removeBtn = document.createElement('button')
			removeBtn.innerHTML = 'X'
			removeBtn.addEventListener('click', onClick)

			return removeBtn
		}

		function addTodotoDOM (todo) {
			const node = document.createElement('li')
			const text = document.createTextNode(todo.name)

			const removeBtn = createRemoveButton(() => {
				store.dispatch(removeTodoAction(todo.id))
			})

			node.appendChild(text)
			node.appendChild(removeBtn)
			document.getElementById('todos')
				.appendChild(node)

			node.style.textDecoration = todo.complete ? 'line-through' : 'none'
			node.addEventListener('click', () => {
				store.dispatch(toggleTodoAction(todo.id))
			})
		}

		function addGoaltoDOM (goal) {
			const node = document.createElement('li')
			const text = document.createTextNode(goal.name)
			const removeBtn = createRemoveButton(() => {
				store.dispatch(removeGoalAction(goal.id))
			})

			node.appendChild(text)
			node.appendChild(removeBtn)
			document.getElementById('goals')
				.append(node)

		}
	</script>
</body>
</html>